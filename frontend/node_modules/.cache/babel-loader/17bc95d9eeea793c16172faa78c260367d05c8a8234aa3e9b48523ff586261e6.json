{"ast":null,"code":"// WebRTCService.js - Minimal real-time audio streaming with WebRTC\nclass WebRTCService {\n  constructor() {\n    this.listeners = new Set();\n    this.isStreaming = false;\n    this.mediaStream = null;\n    this.audioContext = null;\n    this.processor = null;\n    this.signalingSocket = null;\n    this.currentLanguage = 'en';\n  }\n  setLanguage(language) {\n    this.currentLanguage = language;\n  }\n  addListener(callback) {\n    this.listeners.add(callback);\n    if (this.listeners.size === 1 && !this.isStreaming) this.startAudioStreaming();\n  }\n  removeListener(callback) {\n    this.listeners.delete(callback);\n    if (this.listeners.size === 0) this.stopAudioStreaming();\n  }\n  notifyListeners(message) {\n    this.listeners.forEach(cb => {\n      try {\n        cb(message);\n      } catch {}\n    });\n  }\n  async startAudioStreaming() {\n    if (this.isStreaming) return;\n    try {\n      this.notifyListeners({\n        type: 'status',\n        data: 'Starting audio...'\n      });\n      this.mediaStream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      this.notifyListeners({\n        type: 'status',\n        data: 'Microphone ready ‚úÖ'\n      });\n      await this.createWebSocketConnection();\n      await this.setupAudioProcessing();\n      this.isStreaming = true;\n    } catch (error) {\n      this.notifyListeners({\n        type: 'status',\n        data: `Error: ${error.message} ‚ùå`\n      });\n    }\n  }\n  async createWebSocketConnection() {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket('ws://localhost:8000/webrtc');\n      ws.onopen = () => {\n        this.signalingSocket = ws;\n        this.notifyListeners({\n          type: 'status',\n          data: 'Connected ‚úÖ'\n        });\n        ws.onmessage = event => {\n          try {\n            const data = JSON.parse(event.data);\n            if (data.type === 'transcription') this.notifyListeners({\n              type: 'transcription',\n              data: data.text\n            });else if (data.type === 'status') this.notifyListeners({\n              type: 'status',\n              data: data.message\n            });\n          } catch {}\n        };\n        resolve();\n      };\n      ws.onerror = e => {\n        this.notifyListeners({\n          type: 'status',\n          data: 'Connection error ‚ùå'\n        });\n        reject(e);\n      };\n      ws.onclose = () => {\n        this.signalingSocket = null;\n        this.notifyListeners({\n          type: 'status',\n          data: 'Disconnected ‚ùå'\n        });\n      };\n    });\n  }\n  async setupAudioProcessing() {\n    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    const source = this.audioContext.createMediaStreamSource(this.mediaStream);\n    const bufferSize = 4096;\n    this.processor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);\n    this.processor.onaudioprocess = event => {\n      var _this$signalingSocket;\n      if (((_this$signalingSocket = this.signalingSocket) === null || _this$signalingSocket === void 0 ? void 0 : _this$signalingSocket.readyState) === WebSocket.OPEN) {\n        const input = event.inputBuffer.getChannelData(0);\n        const pcm = new Int16Array(input.length);\n        for (let i = 0; i < input.length; i++) pcm[i] = Math.max(-1, Math.min(1, input[i])) * 32767;\n        this.signalingSocket.send(pcm.buffer);\n      }\n    };\n    source.connect(this.processor);\n    this.processor.connect(this.audioContext.destination);\n    this.notifyListeners({\n      type: 'status',\n      data: 'Recording... üî¥'\n    });\n  }\n  stopAudioStreaming() {\n    this.isStreaming = false;\n    if (this.processor) {\n      this.processor.disconnect();\n      this.processor = null;\n    }\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n    if (this.signalingSocket) {\n      this.signalingSocket.close();\n      this.signalingSocket = null;\n    }\n    if (this.mediaStream) {\n      this.mediaStream.getTracks().forEach(t => t.stop());\n      this.mediaStream = null;\n    }\n    this.notifyListeners({\n      type: 'status',\n      data: 'Stopped ‚èπÔ∏è'\n    });\n  }\n  forceCleanup() {\n    this.listeners.clear();\n    this.stopAudioStreaming();\n  }\n}\nconst webRTCService = new WebRTCService();\nif (typeof window !== 'undefined') window.webRTCService = webRTCService;\nexport default webRTCService;","map":{"version":3,"names":["WebRTCService","constructor","listeners","Set","isStreaming","mediaStream","audioContext","processor","signalingSocket","currentLanguage","setLanguage","language","addListener","callback","add","size","startAudioStreaming","removeListener","delete","stopAudioStreaming","notifyListeners","message","forEach","cb","type","data","navigator","mediaDevices","getUserMedia","audio","createWebSocketConnection","setupAudioProcessing","error","Promise","resolve","reject","ws","WebSocket","onopen","onmessage","event","JSON","parse","text","onerror","e","onclose","window","AudioContext","webkitAudioContext","source","createMediaStreamSource","bufferSize","createScriptProcessor","onaudioprocess","_this$signalingSocket","readyState","OPEN","input","inputBuffer","getChannelData","pcm","Int16Array","length","i","Math","max","min","send","buffer","connect","destination","disconnect","close","getTracks","t","stop","forceCleanup","clear","webRTCService"],"sources":["/Users/tyler/Documents/spoken/frontend/src/WebRTCService.js"],"sourcesContent":["// WebRTCService.js - Minimal real-time audio streaming with WebRTC\nclass WebRTCService {\n  constructor() {\n    this.listeners = new Set();\n    this.isStreaming = false;\n    this.mediaStream = null;\n    this.audioContext = null;\n    this.processor = null;\n    this.signalingSocket = null;\n    this.currentLanguage = 'en';\n  }\n\n  setLanguage(language) {\n    this.currentLanguage = language;\n  }\n\n  addListener(callback) {\n    this.listeners.add(callback);\n    if (this.listeners.size === 1 && !this.isStreaming) this.startAudioStreaming();\n  }\n\n  removeListener(callback) {\n    this.listeners.delete(callback);\n    if (this.listeners.size === 0) this.stopAudioStreaming();\n  }\n\n  notifyListeners(message) {\n    this.listeners.forEach(cb => { try { cb(message); } catch {} });\n  }\n\n  async startAudioStreaming() {\n    if (this.isStreaming) return;\n    try {\n      this.notifyListeners({ type: 'status', data: 'Starting audio...' });\n      this.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      this.notifyListeners({ type: 'status', data: 'Microphone ready ‚úÖ' });\n      await this.createWebSocketConnection();\n      await this.setupAudioProcessing();\n      this.isStreaming = true;\n    } catch (error) {\n      this.notifyListeners({ type: 'status', data: `Error: ${error.message} ‚ùå` });\n    }\n  }\n\n  async createWebSocketConnection() {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket('ws://localhost:8000/webrtc');\n      ws.onopen = () => {\n        this.signalingSocket = ws;\n        this.notifyListeners({ type: 'status', data: 'Connected ‚úÖ' });\n        ws.onmessage = (event) => {\n          try {\n            const data = JSON.parse(event.data);\n            if (data.type === 'transcription') this.notifyListeners({ type: 'transcription', data: data.text });\n            else if (data.type === 'status') this.notifyListeners({ type: 'status', data: data.message });\n          } catch {}\n        };\n        resolve();\n      };\n      ws.onerror = (e) => { this.notifyListeners({ type: 'status', data: 'Connection error ‚ùå' }); reject(e); };\n      ws.onclose = () => { this.signalingSocket = null; this.notifyListeners({ type: 'status', data: 'Disconnected ‚ùå' }); };\n    });\n  }\n\n  async setupAudioProcessing() {\n    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    const source = this.audioContext.createMediaStreamSource(this.mediaStream);\n    const bufferSize = 4096;\n    this.processor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);\n    this.processor.onaudioprocess = (event) => {\n      if (this.signalingSocket?.readyState === WebSocket.OPEN) {\n        const input = event.inputBuffer.getChannelData(0);\n        const pcm = new Int16Array(input.length);\n        for (let i = 0; i < input.length; i++) pcm[i] = Math.max(-1, Math.min(1, input[i])) * 32767;\n        this.signalingSocket.send(pcm.buffer);\n      }\n    };\n    source.connect(this.processor);\n    this.processor.connect(this.audioContext.destination);\n    this.notifyListeners({ type: 'status', data: 'Recording... üî¥' });\n  }\n\n  stopAudioStreaming() {\n    this.isStreaming = false;\n    if (this.processor) { this.processor.disconnect(); this.processor = null; }\n    if (this.audioContext) { this.audioContext.close(); this.audioContext = null; }\n    if (this.signalingSocket) { this.signalingSocket.close(); this.signalingSocket = null; }\n    if (this.mediaStream) { this.mediaStream.getTracks().forEach(t => t.stop()); this.mediaStream = null; }\n    this.notifyListeners({ type: 'status', data: 'Stopped ‚èπÔ∏è' });\n  }\n\n  forceCleanup() {\n    this.listeners.clear();\n    this.stopAudioStreaming();\n  }\n}\n\nconst webRTCService = new WebRTCService();\nif (typeof window !== 'undefined') window.webRTCService = webRTCService;\nexport default webRTCService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}