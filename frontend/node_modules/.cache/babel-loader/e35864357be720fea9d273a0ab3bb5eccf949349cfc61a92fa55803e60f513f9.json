{"ast":null,"code":"// WebSocketService.js - Singleton WebSocket connection\nclass WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.connected = false;\n    this.connecting = false; // Add connecting state\n    this.listeners = new Set();\n    this.retryInterval = 3000; // Start with 3 seconds\n    this.retryTimeout = null;\n    this.connectTimeout = null; // Add debounce timeout\n\n    // Cleanup on page unload\n    window.addEventListener('beforeunload', () => {\n      console.log('🚪 Page unloading, disconnecting WebSocket');\n      this.disconnect();\n    });\n\n    // Handle page visibility changes\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden) {\n        console.log('📴 Page hidden, maintaining connection');\n      } else {\n        console.log('👁️ Page visible, checking connection');\n        if (!this.connected && this.listeners.size > 0) {\n          this.connect();\n        }\n      }\n    });\n  }\n  addListener(callback) {\n    this.listeners.add(callback);\n\n    // If already connected, immediately call the callback with current status\n    if (this.connected) {\n      callback({\n        type: 'status',\n        data: 'Connected ✅'\n      });\n    }\n  }\n  removeListener(callback) {\n    this.listeners.delete(callback);\n  }\n  notifyListeners(message) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(message);\n      } catch (error) {\n        console.error('Error in WebSocket listener:', error);\n      }\n    });\n  }\n  connect() {\n    if (this.connected || this.connecting) {\n      console.log('✅ WebSocket already connected/connecting, skipping');\n      return;\n    }\n\n    // Clear any pending connection attempt\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n    }\n\n    // Debounce connection attempts - wait 100ms\n    this.connectTimeout = setTimeout(() => {\n      this._doConnect();\n    }, 100);\n  }\n  _doConnect() {\n    if (this.connected || this.connecting) {\n      console.log('✅ WebSocket already connected/connecting during _doConnect, skipping');\n      return;\n    }\n    this.connecting = true;\n\n    // Always cleanup any existing connection first\n    if (this.ws) {\n      console.log('⚠️ Cleaning up existing WebSocket before creating new one');\n      this.disconnect();\n    }\n    console.log('🔌 Creating WebSocket connection...');\n    try {\n      this.ws = new WebSocket('ws://localhost:8000/ws');\n      this.ws.onopen = () => {\n        console.log('✅ WebSocket connected successfully');\n        this.connected = true;\n        this.connecting = false; // Clear connecting state\n        this.retryInterval = 3000; // reset retry interval to initial value\n        this.notifyListeners({\n          type: 'status',\n          data: 'Connected ✅'\n        });\n      };\n      this.ws.onmessage = event => {\n        const transcription = event.data;\n        console.log('📥 Received transcription:', transcription);\n        this.notifyListeners({\n          type: 'transcription',\n          data: transcription\n        });\n      };\n      this.ws.onclose = event => {\n        console.log('❌ WebSocket disconnected. Code:', event.code, 'Reason:', event.reason);\n        this.connected = false;\n        this.connecting = false; // Clear connecting state\n        this.ws = null;\n        this.notifyListeners({\n          type: 'status',\n          data: 'Disconnected ❌'\n        });\n\n        // Only retry on abnormal closure and if we have active listeners\n        if (event.code !== 1000 && this.listeners.size > 0) {\n          console.log('🔄 Will retry connection in', this.retryInterval, 'ms');\n          this.notifyListeners({\n            type: 'status',\n            data: 'Reconnecting...'\n          });\n          this.retryTimeout = setTimeout(() => {\n            this.connect();\n          }, this.retryInterval);\n          this.retryInterval = Math.min(this.retryInterval * 2, 30000);\n        }\n      };\n      this.ws.onerror = error => {\n        console.error('❌ WebSocket error:', error);\n        this.connecting = false; // Clear connecting state on error\n        this.notifyListeners({\n          type: 'status',\n          data: 'Error ❌'\n        });\n      };\n    } catch (error) {\n      console.error('❌ Failed to create WebSocket:', error);\n      this.connecting = false; // Clear connecting state on error\n      this.notifyListeners({\n        type: 'status',\n        data: 'Failed ❌'\n      });\n    }\n  }\n  disconnect() {\n    console.log('🧹 Disconnecting WebSocket...');\n\n    // Clear any pending retry\n    if (this.retryTimeout) {\n      clearTimeout(this.retryTimeout);\n      this.retryTimeout = null;\n    }\n\n    // Clear any pending connection attempt\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = null;\n    }\n\n    // Close the WebSocket connection\n    if (this.ws) {\n      this.connected = false;\n      this.connecting = false; // Clear connecting state\n\n      // Remove event handlers to prevent any callbacks\n      this.ws.onopen = null;\n      this.ws.onmessage = null;\n      this.ws.onclose = null;\n      this.ws.onerror = null;\n\n      // Close the connection\n      if (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING) {\n        this.ws.close(1000, 'Manual disconnect');\n      }\n      this.ws = null;\n    }\n    console.log('✅ WebSocket disconnected and cleaned up');\n  }\n\n  // Force cleanup - useful for debugging\n  forceCleanup() {\n    console.log('🔥 Force cleanup: clearing all listeners and disconnecting');\n    this.listeners.clear();\n    this.disconnect();\n  }\n}\n\n// Create singleton instance\nconst webSocketService = new WebSocketService();\n\n// Make it available globally for debugging\nif (typeof window !== 'undefined') {\n  window.webSocketService = webSocketService;\n  console.log('🔧 WebSocketService available globally as window.webSocketService');\n}\nexport default webSocketService;","map":{"version":3,"names":["WebSocketService","constructor","ws","connected","connecting","listeners","Set","retryInterval","retryTimeout","connectTimeout","window","addEventListener","console","log","disconnect","document","hidden","size","connect","addListener","callback","add","type","data","removeListener","delete","notifyListeners","message","forEach","error","clearTimeout","setTimeout","_doConnect","WebSocket","onopen","onmessage","event","transcription","onclose","code","reason","Math","min","onerror","readyState","OPEN","CONNECTING","close","forceCleanup","clear","webSocketService"],"sources":["/Users/tyler/Documents/SpeakNow/frontend/src/WebSocketService.js"],"sourcesContent":["// WebSocketService.js - Singleton WebSocket connection\nclass WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.connected = false;\n    this.connecting = false; // Add connecting state\n    this.listeners = new Set();\n    this.retryInterval = 3000; // Start with 3 seconds\n    this.retryTimeout = null;\n    this.connectTimeout = null; // Add debounce timeout\n    \n    // Cleanup on page unload\n    window.addEventListener('beforeunload', () => {\n      console.log('🚪 Page unloading, disconnecting WebSocket');\n      this.disconnect();\n    });\n    \n    // Handle page visibility changes\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden) {\n        console.log('📴 Page hidden, maintaining connection');\n      } else {\n        console.log('👁️ Page visible, checking connection');\n        if (!this.connected && this.listeners.size > 0) {\n          this.connect();\n        }\n      }\n    });\n  }\n\n  addListener(callback) {\n    this.listeners.add(callback);\n    \n    // If already connected, immediately call the callback with current status\n    if (this.connected) {\n      callback({ type: 'status', data: 'Connected ✅' });\n    }\n  }\n\n  removeListener(callback) {\n    this.listeners.delete(callback);\n  }\n\n  notifyListeners(message) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(message);\n      } catch (error) {\n        console.error('Error in WebSocket listener:', error);\n      }\n    });\n  }\n\n  connect() {\n    if (this.connected || this.connecting) {\n      console.log('✅ WebSocket already connected/connecting, skipping');\n      return;\n    }\n    \n    // Clear any pending connection attempt\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n    }\n    \n    // Debounce connection attempts - wait 100ms\n    this.connectTimeout = setTimeout(() => {\n      this._doConnect();\n    }, 100);\n  }\n  \n  _doConnect() {\n    if (this.connected || this.connecting) {\n      console.log('✅ WebSocket already connected/connecting during _doConnect, skipping');\n      return;\n    }\n    \n    this.connecting = true;\n    \n    // Always cleanup any existing connection first\n    if (this.ws) {\n      console.log('⚠️ Cleaning up existing WebSocket before creating new one');\n      this.disconnect();\n    }\n\n    console.log('🔌 Creating WebSocket connection...');\n    \n    try {\n      this.ws = new WebSocket('ws://localhost:8000/ws');\n      \n      this.ws.onopen = () => {\n        console.log('✅ WebSocket connected successfully');\n        this.connected = true;\n        this.connecting = false; // Clear connecting state\n        this.retryInterval = 3000; // reset retry interval to initial value\n        this.notifyListeners({ type: 'status', data: 'Connected ✅' });\n      };\n\n      this.ws.onmessage = (event) => {\n        const transcription = event.data;\n        console.log('📥 Received transcription:', transcription);\n        this.notifyListeners({ type: 'transcription', data: transcription });\n      };\n\n      this.ws.onclose = (event) => {\n        console.log('❌ WebSocket disconnected. Code:', event.code, 'Reason:', event.reason);\n        this.connected = false;\n        this.connecting = false; // Clear connecting state\n        this.ws = null;\n        this.notifyListeners({ type: 'status', data: 'Disconnected ❌' });\n        \n        // Only retry on abnormal closure and if we have active listeners\n        if (event.code !== 1000 && this.listeners.size > 0) {\n          console.log('🔄 Will retry connection in', this.retryInterval, 'ms');\n          this.notifyListeners({ type: 'status', data: 'Reconnecting...' });\n          this.retryTimeout = setTimeout(() => {\n            this.connect();\n          }, this.retryInterval);\n          this.retryInterval = Math.min(this.retryInterval * 2, 30000);\n        }\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('❌ WebSocket error:', error);\n        this.connecting = false; // Clear connecting state on error\n        this.notifyListeners({ type: 'status', data: 'Error ❌' });\n      };\n      \n    } catch (error) {\n      console.error('❌ Failed to create WebSocket:', error);\n      this.connecting = false; // Clear connecting state on error\n      this.notifyListeners({ type: 'status', data: 'Failed ❌' });\n    }\n  }\n\n  disconnect() {\n    console.log('🧹 Disconnecting WebSocket...');\n    \n    // Clear any pending retry\n    if (this.retryTimeout) {\n      clearTimeout(this.retryTimeout);\n      this.retryTimeout = null;\n    }\n    \n    // Clear any pending connection attempt\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = null;\n    }\n    \n    // Close the WebSocket connection\n    if (this.ws) {\n      this.connected = false;\n      this.connecting = false; // Clear connecting state\n      \n      // Remove event handlers to prevent any callbacks\n      this.ws.onopen = null;\n      this.ws.onmessage = null;\n      this.ws.onclose = null;\n      this.ws.onerror = null;\n      \n      // Close the connection\n      if (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING) {\n        this.ws.close(1000, 'Manual disconnect');\n      }\n      \n      this.ws = null;\n    }\n    \n    console.log('✅ WebSocket disconnected and cleaned up');\n  }\n\n  // Force cleanup - useful for debugging\n  forceCleanup() {\n    console.log('🔥 Force cleanup: clearing all listeners and disconnecting');\n    this.listeners.clear();\n    this.disconnect();\n  }\n}\n\n// Create singleton instance\nconst webSocketService = new WebSocketService();\n\n// Make it available globally for debugging\nif (typeof window !== 'undefined') {\n  window.webSocketService = webSocketService;\n  console.log('🔧 WebSocketService available globally as window.webSocketService');\n}\n\nexport default webSocketService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}