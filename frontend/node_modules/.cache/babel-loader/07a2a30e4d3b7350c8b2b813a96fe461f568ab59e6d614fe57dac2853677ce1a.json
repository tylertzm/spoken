{"ast":null,"code":"// WebRTCService.js - Real-time audio streaming with WebRTC\nclass WebRTCService {\n  constructor() {\n    this.listeners = new Set();\n    this.isStreaming = false;\n    this.mediaStream = null;\n    this.peerConnection = null;\n    this.dataChannel = null;\n    this.audioContext = null;\n    this.mediaRecorder = null;\n  }\n  addListener(callback) {\n    this.listeners.add(callback);\n\n    // Start streaming when first listener is added\n    if (this.listeners.size === 1 && !this.isStreaming) {\n      this.startAudioStreaming();\n    }\n  }\n  removeListener(callback) {\n    this.listeners.delete(callback);\n\n    // Stop streaming when no listeners remain\n    if (this.listeners.size === 0) {\n      this.stopAudioStreaming();\n    }\n  }\n  notifyListeners(message) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(message);\n      } catch (error) {\n        console.error('Error in WebRTC listener:', error);\n      }\n    });\n  }\n  async startAudioStreaming() {\n    if (this.isStreaming) return;\n    try {\n      console.log('🎙️ Starting WebRTC audio streaming...');\n      this.notifyListeners({\n        type: 'status',\n        data: 'Starting audio...'\n      });\n\n      // Get microphone access with specific constraints for better compatibility\n      this.mediaStream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true,\n          sampleRate: 16000,\n          channelCount: 1 // Mono audio\n        }\n      });\n      console.log('🎤 Microphone access granted');\n      this.notifyListeners({\n        type: 'status',\n        data: 'Microphone ready ✅'\n      });\n\n      // Create WebSocket connection for signaling\n      await this.createWebSocketConnection();\n\n      // Set up audio processing with Web Audio API for better control\n      this.setupWebAudioProcessing();\n      this.isStreaming = true;\n      console.log('🚀 WebRTC audio streaming started');\n    } catch (error) {\n      console.error('❌ Failed to start audio streaming:', error);\n      this.notifyListeners({\n        type: 'status',\n        data: `Error: ${error.message} ❌`\n      });\n    }\n  }\n  async createWebSocketConnection() {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket('ws://localhost:8000/webrtc');\n      ws.onopen = () => {\n        console.log('📡 WebSocket signaling connected');\n        this.signalingSocket = ws;\n        ws.onmessage = event => {\n          const data = JSON.parse(event.data);\n          if (data.type === 'transcription') {\n            console.log('📥 Received transcription:', data.text);\n            this.notifyListeners({\n              type: 'transcription',\n              data: data.text\n            });\n          }\n        };\n        resolve();\n      };\n      ws.onerror = error => {\n        console.error('❌ WebSocket signaling error:', error);\n        reject(error);\n      };\n      ws.onclose = () => {\n        console.log('📡 WebSocket signaling disconnected');\n        this.notifyListeners({\n          type: 'status',\n          data: 'Disconnected ❌'\n        });\n      };\n    });\n  }\n  setupMediaRecorder() {\n    // Use MediaRecorder to capture audio chunks\n    this.mediaRecorder = new MediaRecorder(this.mediaStream, {\n      mimeType: 'audio/webm;codecs=opus',\n      audioBitsPerSecond: 16000\n    });\n    this.mediaRecorder.ondataavailable = event => {\n      var _this$signalingSocket;\n      if (event.data.size > 0 && ((_this$signalingSocket = this.signalingSocket) === null || _this$signalingSocket === void 0 ? void 0 : _this$signalingSocket.readyState) === WebSocket.OPEN) {\n        // Convert blob to array buffer for sending\n        console.log('🎵 Sending audio chunk, size:', event.data.size);\n        event.data.arrayBuffer().then(arrayBuffer => {\n          this.signalingSocket.send(arrayBuffer);\n        });\n      }\n    };\n    this.mediaRecorder.onerror = event => {\n      console.error('❌ MediaRecorder error:', event.error);\n      this.notifyListeners({\n        type: 'status',\n        data: 'Recording error ❌'\n      });\n    };\n\n    // Start recording with smaller chunks for better real-time performance\n    this.mediaRecorder.start(500); // 500ms chunks for more responsive transcription\n    console.log('🔴 Recording started with 500ms chunks');\n    this.notifyListeners({\n      type: 'status',\n      data: 'Recording... 🔴'\n    });\n  }\n  stopAudioStreaming() {\n    console.log('🛑 Stopping WebRTC audio streaming...');\n    this.isStreaming = false;\n\n    // Stop MediaRecorder\n    if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {\n      this.mediaRecorder.stop();\n    }\n\n    // Close WebSocket\n    if (this.signalingSocket) {\n      this.signalingSocket.close();\n      this.signalingSocket = null;\n    }\n\n    // Stop media stream\n    if (this.mediaStream) {\n      this.mediaStream.getTracks().forEach(track => track.stop());\n      this.mediaStream = null;\n    }\n    this.notifyListeners({\n      type: 'status',\n      data: 'Stopped ⏹️'\n    });\n    console.log('✅ WebRTC audio streaming stopped');\n  }\n\n  // Force cleanup - useful for debugging\n  forceCleanup() {\n    console.log('🔥 Force cleanup: clearing all listeners and stopping streaming');\n    this.listeners.clear();\n    this.stopAudioStreaming();\n  }\n}\n\n// Create singleton instance\nconst webRTCService = new WebRTCService();\n\n// Make it available globally for debugging\nif (typeof window !== 'undefined') {\n  window.webRTCService = webRTCService;\n  console.log('🔧 WebRTCService available globally as window.webRTCService');\n}\nexport default webRTCService;","map":{"version":3,"names":["WebRTCService","constructor","listeners","Set","isStreaming","mediaStream","peerConnection","dataChannel","audioContext","mediaRecorder","addListener","callback","add","size","startAudioStreaming","removeListener","delete","stopAudioStreaming","notifyListeners","message","forEach","error","console","log","type","data","navigator","mediaDevices","getUserMedia","audio","echoCancellation","noiseSuppression","autoGainControl","sampleRate","channelCount","createWebSocketConnection","setupWebAudioProcessing","Promise","resolve","reject","ws","WebSocket","onopen","signalingSocket","onmessage","event","JSON","parse","text","onerror","onclose","setupMediaRecorder","MediaRecorder","mimeType","audioBitsPerSecond","ondataavailable","_this$signalingSocket","readyState","OPEN","arrayBuffer","then","send","start","state","stop","close","getTracks","track","forceCleanup","clear","webRTCService","window"],"sources":["/Users/tyler/Documents/SpeakNow/frontend/src/WebRTCService.js"],"sourcesContent":["// WebRTCService.js - Real-time audio streaming with WebRTC\nclass WebRTCService {\n  constructor() {\n    this.listeners = new Set();\n    this.isStreaming = false;\n    this.mediaStream = null;\n    this.peerConnection = null;\n    this.dataChannel = null;\n    this.audioContext = null;\n    this.mediaRecorder = null;\n  }\n\n  addListener(callback) {\n    this.listeners.add(callback);\n    \n    // Start streaming when first listener is added\n    if (this.listeners.size === 1 && !this.isStreaming) {\n      this.startAudioStreaming();\n    }\n  }\n\n  removeListener(callback) {\n    this.listeners.delete(callback);\n    \n    // Stop streaming when no listeners remain\n    if (this.listeners.size === 0) {\n      this.stopAudioStreaming();\n    }\n  }\n\n  notifyListeners(message) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(message);\n      } catch (error) {\n        console.error('Error in WebRTC listener:', error);\n      }\n    });\n  }\n\n  async startAudioStreaming() {\n    if (this.isStreaming) return;\n\n    try {\n      console.log('🎙️ Starting WebRTC audio streaming...');\n      this.notifyListeners({ type: 'status', data: 'Starting audio...' });\n\n      // Get microphone access with specific constraints for better compatibility\n      this.mediaStream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true,\n          sampleRate: 16000,\n          channelCount: 1  // Mono audio\n        }\n      });\n\n      console.log('🎤 Microphone access granted');\n      this.notifyListeners({ type: 'status', data: 'Microphone ready ✅' });\n\n      // Create WebSocket connection for signaling\n      await this.createWebSocketConnection();\n\n      // Set up audio processing with Web Audio API for better control\n      this.setupWebAudioProcessing();\n\n      this.isStreaming = true;\n      console.log('🚀 WebRTC audio streaming started');\n\n    } catch (error) {\n      console.error('❌ Failed to start audio streaming:', error);\n      this.notifyListeners({ type: 'status', data: `Error: ${error.message} ❌` });\n    }\n  }\n\n  async createWebSocketConnection() {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket('ws://localhost:8000/webrtc');\n      \n      ws.onopen = () => {\n        console.log('📡 WebSocket signaling connected');\n        this.signalingSocket = ws;\n        \n        ws.onmessage = (event) => {\n          const data = JSON.parse(event.data);\n          if (data.type === 'transcription') {\n            console.log('📥 Received transcription:', data.text);\n            this.notifyListeners({ type: 'transcription', data: data.text });\n          }\n        };\n        \n        resolve();\n      };\n      \n      ws.onerror = (error) => {\n        console.error('❌ WebSocket signaling error:', error);\n        reject(error);\n      };\n      \n      ws.onclose = () => {\n        console.log('📡 WebSocket signaling disconnected');\n        this.notifyListeners({ type: 'status', data: 'Disconnected ❌' });\n      };\n    });\n  }\n\n  setupMediaRecorder() {\n    // Use MediaRecorder to capture audio chunks\n    this.mediaRecorder = new MediaRecorder(this.mediaStream, {\n      mimeType: 'audio/webm;codecs=opus',\n      audioBitsPerSecond: 16000\n    });\n\n    this.mediaRecorder.ondataavailable = (event) => {\n      if (event.data.size > 0 && this.signalingSocket?.readyState === WebSocket.OPEN) {\n        // Convert blob to array buffer for sending\n        console.log('🎵 Sending audio chunk, size:', event.data.size);\n        event.data.arrayBuffer().then(arrayBuffer => {\n          this.signalingSocket.send(arrayBuffer);\n        });\n      }\n    };\n\n    this.mediaRecorder.onerror = (event) => {\n      console.error('❌ MediaRecorder error:', event.error);\n      this.notifyListeners({ type: 'status', data: 'Recording error ❌' });\n    };\n\n    // Start recording with smaller chunks for better real-time performance\n    this.mediaRecorder.start(500); // 500ms chunks for more responsive transcription\n    console.log('🔴 Recording started with 500ms chunks');\n    this.notifyListeners({ type: 'status', data: 'Recording... 🔴' });\n  }\n\n  stopAudioStreaming() {\n    console.log('🛑 Stopping WebRTC audio streaming...');\n    this.isStreaming = false;\n\n    // Stop MediaRecorder\n    if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {\n      this.mediaRecorder.stop();\n    }\n\n    // Close WebSocket\n    if (this.signalingSocket) {\n      this.signalingSocket.close();\n      this.signalingSocket = null;\n    }\n\n    // Stop media stream\n    if (this.mediaStream) {\n      this.mediaStream.getTracks().forEach(track => track.stop());\n      this.mediaStream = null;\n    }\n\n    this.notifyListeners({ type: 'status', data: 'Stopped ⏹️' });\n    console.log('✅ WebRTC audio streaming stopped');\n  }\n\n  // Force cleanup - useful for debugging\n  forceCleanup() {\n    console.log('🔥 Force cleanup: clearing all listeners and stopping streaming');\n    this.listeners.clear();\n    this.stopAudioStreaming();\n  }\n}\n\n// Create singleton instance\nconst webRTCService = new WebRTCService();\n\n// Make it available globally for debugging\nif (typeof window !== 'undefined') {\n  window.webRTCService = webRTCService;\n  console.log('🔧 WebRTCService available globally as window.webRTCService');\n}\n\nexport default webRTCService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}