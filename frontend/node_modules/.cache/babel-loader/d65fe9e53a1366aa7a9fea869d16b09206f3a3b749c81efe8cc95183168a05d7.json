{"ast":null,"code":"// WebSocketService.js - Singleton WebSocket connection\nclass WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.connected = false;\n    this.listeners = new Set();\n    this.retryInterval = 1000;\n    this.retryTimeout = null;\n  }\n  addListener(callback) {\n    this.listeners.add(callback);\n\n    // If already connected, immediately call the callback with current status\n    if (this.connected) {\n      callback({\n        type: 'status',\n        data: 'Connected ‚úÖ'\n      });\n    }\n  }\n  removeListener(callback) {\n    this.listeners.delete(callback);\n  }\n  notifyListeners(message) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(message);\n      } catch (error) {\n        console.error('Error in WebSocket listener:', error);\n      }\n    });\n  }\n  connect() {\n    if (this.connected || this.ws) {\n      console.log('WebSocket already connected or connecting');\n      return;\n    }\n    console.log('üîå Creating WebSocket connection...');\n    try {\n      this.ws = new WebSocket('ws://localhost:8000/ws');\n      this.ws.onopen = () => {\n        console.log('‚úÖ WebSocket connected successfully');\n        this.connected = true;\n        this.retryInterval = 1000; // reset retry interval\n        this.notifyListeners({\n          type: 'status',\n          data: 'Connected ‚úÖ'\n        });\n      };\n      this.ws.onmessage = event => {\n        const transcription = event.data;\n        console.log('üì• Received transcription:', transcription);\n        this.notifyListeners({\n          type: 'transcription',\n          data: transcription\n        });\n      };\n      this.ws.onclose = event => {\n        console.log('‚ùå WebSocket disconnected. Code:', event.code, 'Reason:', event.reason);\n        this.connected = false;\n        this.ws = null;\n        this.notifyListeners({\n          type: 'status',\n          data: 'Disconnected ‚ùå'\n        });\n\n        // Only retry on abnormal closure\n        if (event.code !== 1000) {\n          this.notifyListeners({\n            type: 'status',\n            data: 'Reconnecting...'\n          });\n          this.retryTimeout = setTimeout(() => {\n            this.connect();\n          }, this.retryInterval);\n          this.retryInterval = Math.min(this.retryInterval * 2, 30000);\n        }\n      };\n      this.ws.onerror = error => {\n        console.error('‚ùå WebSocket error:', error);\n        this.notifyListeners({\n          type: 'status',\n          data: 'Error ‚ùå'\n        });\n      };\n    } catch (error) {\n      console.error('‚ùå Failed to create WebSocket:', error);\n      this.notifyListeners({\n        type: 'status',\n        data: 'Failed ‚ùå'\n      });\n    }\n  }\n  disconnect() {\n    console.log('üßπ Disconnecting WebSocket...');\n    if (this.retryTimeout) {\n      clearTimeout(this.retryTimeout);\n      this.retryTimeout = null;\n    }\n    if (this.ws) {\n      this.connected = false;\n      this.ws.onopen = null;\n      this.ws.onmessage = null;\n      this.ws.onclose = null;\n      this.ws.onerror = null;\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n}\n\n// Create singleton instance\nconst webSocketService = new WebSocketService();\nexport default webSocketService;","map":{"version":3,"names":["WebSocketService","constructor","ws","connected","listeners","Set","retryInterval","retryTimeout","addListener","callback","add","type","data","removeListener","delete","notifyListeners","message","forEach","error","console","connect","log","WebSocket","onopen","onmessage","event","transcription","onclose","code","reason","setTimeout","Math","min","onerror","disconnect","clearTimeout","close","webSocketService"],"sources":["/Users/tyler/Documents/SpeakNow/frontend/src/WebSocketService.js"],"sourcesContent":["// WebSocketService.js - Singleton WebSocket connection\nclass WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.connected = false;\n    this.listeners = new Set();\n    this.retryInterval = 1000;\n    this.retryTimeout = null;\n  }\n\n  addListener(callback) {\n    this.listeners.add(callback);\n    \n    // If already connected, immediately call the callback with current status\n    if (this.connected) {\n      callback({ type: 'status', data: 'Connected ‚úÖ' });\n    }\n  }\n\n  removeListener(callback) {\n    this.listeners.delete(callback);\n  }\n\n  notifyListeners(message) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(message);\n      } catch (error) {\n        console.error('Error in WebSocket listener:', error);\n      }\n    });\n  }\n\n  connect() {\n    if (this.connected || this.ws) {\n      console.log('WebSocket already connected or connecting');\n      return;\n    }\n\n    console.log('üîå Creating WebSocket connection...');\n    \n    try {\n      this.ws = new WebSocket('ws://localhost:8000/ws');\n      \n      this.ws.onopen = () => {\n        console.log('‚úÖ WebSocket connected successfully');\n        this.connected = true;\n        this.retryInterval = 1000; // reset retry interval\n        this.notifyListeners({ type: 'status', data: 'Connected ‚úÖ' });\n      };\n\n      this.ws.onmessage = (event) => {\n        const transcription = event.data;\n        console.log('üì• Received transcription:', transcription);\n        this.notifyListeners({ type: 'transcription', data: transcription });\n      };\n\n      this.ws.onclose = (event) => {\n        console.log('‚ùå WebSocket disconnected. Code:', event.code, 'Reason:', event.reason);\n        this.connected = false;\n        this.ws = null;\n        this.notifyListeners({ type: 'status', data: 'Disconnected ‚ùå' });\n        \n        // Only retry on abnormal closure\n        if (event.code !== 1000) {\n          this.notifyListeners({ type: 'status', data: 'Reconnecting...' });\n          this.retryTimeout = setTimeout(() => {\n            this.connect();\n          }, this.retryInterval);\n          this.retryInterval = Math.min(this.retryInterval * 2, 30000);\n        }\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('‚ùå WebSocket error:', error);\n        this.notifyListeners({ type: 'status', data: 'Error ‚ùå' });\n      };\n      \n    } catch (error) {\n      console.error('‚ùå Failed to create WebSocket:', error);\n      this.notifyListeners({ type: 'status', data: 'Failed ‚ùå' });\n    }\n  }\n\n  disconnect() {\n    console.log('üßπ Disconnecting WebSocket...');\n    \n    if (this.retryTimeout) {\n      clearTimeout(this.retryTimeout);\n      this.retryTimeout = null;\n    }\n    \n    if (this.ws) {\n      this.connected = false;\n      this.ws.onopen = null;\n      this.ws.onmessage = null;\n      this.ws.onclose = null;\n      this.ws.onerror = null;\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n}\n\n// Create singleton instance\nconst webSocketService = new WebSocketService();\n\nexport default webSocketService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}