{"ast":null,"code":"var _jsxFileName = \"/Users/tyler/Documents/spoken/frontend/src/App.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport TranscriptionDisplay from './components/TranscriptionDisplay/TranscriptionDisplay';\nimport TranscriptionHistory from './components/TranscriptionHistory/TranscriptionHistory';\nimport webRTCService from './WebRTCService';\nimport WebSearchDisplay from './components/WebSearchDisplay/WebSearchDisplay';\nimport GroqKeyModal from './components/GroqKeyModal';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [transcription, setTranscription] = useState('');\n  const [allTranscriptions, setAllTranscriptions] = useState([]);\n  const [imageUrls, setImageUrls] = useState({}); // Store images by chunkId\n  const [connectionStatus, setConnectionStatus] = useState('Connecting...');\n  const [selectedLanguage, setSelectedLanguage] = useState('en'); // New state for language\n  const [cleanedTranscriptions, setCleanedTranscriptions] = useState([]); // NEW\n  const [historyFullScreen, setHistoryFullScreen] = useState(false);\n  const [showWebSearch, setShowWebSearch] = useState(false);\n  const [taskSummary, setTaskSummary] = useState('');\n  const [isTranscribing, setIsTranscribing] = useState(true);\n  const clearTranscriptionTimer = useRef(null);\n  const [mainTranscribeSocket, setMainTranscribeSocket] = useState(null);\n  const [finalizedIndexes, setFinalizedIndexes] = useState([]); // NEW: track finalized entries\n  const [showGroqModal, setShowGroqModal] = useState(false);\n  const allTranscriptionsRef = useRef(allTranscriptions);\n  useEffect(() => {\n    const componentId = Math.random().toString(36).substring(2, 11);\n    console.log('ðŸŽ¯ App component mounted with ID:', componentId, 'setting up WebRTC listener');\n    const handleWebRTCMessage = message => {\n      console.log('[App] Received WebRTC message:', message); // Debug log\n      if (message.type === 'status') {\n        setConnectionStatus(message.data);\n      } else if (message.type === 'images') {\n        // Store images for the corresponding transcription\n        setImageUrls(prev => ({\n          ...prev,\n          [message.chunkId]: message.images\n        }));\n        console.log('ðŸ–¼ï¸ Received images for chunk:', message.chunkId, message.images);\n      } else if (message.type === 'history') {\n        // Real-time streaming chunk for history log\n        const text = message.message;\n        // Only add to history if it's not the default chunk sent message\n        if (!text.startsWith('audioData chunk sent')) {\n          setAllTranscriptions(prev => {\n            if (text && (prev.length === 0 || prev[0] !== text)) {\n              return [text, ...prev];\n            }\n            return prev;\n          });\n        }\n      } else if (message.type === 'summary') {\n        // 3-second chunk for summary\n        setCleanedTranscriptions(prev => {\n          const text = message.message;\n          if (text && (prev.length === 0 || prev[0] !== text)) {\n            return [text, ...prev];\n          }\n          return prev;\n        });\n      } else if (message.type === 'transcription') {\n        console.log('[App] Received transcription message.data:', message.data); // Debug log\n        const transcriptionText = message.data;\n\n        // Only update transcription if it's meaningful (not empty or \"No speech detected\")\n        if (transcriptionText && transcriptionText.trim() !== '' && transcriptionText !== '[No speech detected]' && !transcriptionText.includes('[Transcription error:')) {\n          console.log('âœ… Updating live transcription:', transcriptionText);\n          setTranscription(transcriptionText);\n\n          // Clear any existing timer\n          if (clearTranscriptionTimer.current) {\n            clearTimeout(clearTranscriptionTimer.current);\n          }\n\n          // Set a new timer to clear the transcription after 5 seconds of silence\n          clearTranscriptionTimer.current = setTimeout(() => {\n            console.log('â° Clearing transcription after timeout');\n            setTranscription('');\n          }, 5000);\n\n          // Add to history only if it's different from the last one\n          setAllTranscriptions(prev => {\n            if (prev.length === 0 || prev[0] !== transcriptionText) {\n              return [transcriptionText, ...prev];\n            }\n            return prev;\n          });\n        } else {\n          console.log('ðŸ”‡ Ignoring empty/error transcription:', transcriptionText);\n          // Don't update live transcription - keep the previous one visible\n        }\n      }\n    };\n\n    // Add listener - WebRTC streaming will start automatically\n    webRTCService.addListener(handleWebRTCMessage);\n\n    // Setup main-transcribe WebSocket for finalized history\n    const ws = new window.WebSocket('ws://localhost:8000/main-transcribe');\n    ws.onopen = () => {\n      console.log('[MainTranscribe] Connected to /main-transcribe');\n    };\n    ws.onmessage = async event => {\n      try {\n        const message = JSON.parse(event.data);\n        if (message.type === 'history' && message.message) {\n          // Call backend to merge live and finalized history using LLM\n          try {\n            const response = await fetch('http://localhost:8000/merge-history', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json'\n              },\n              body: JSON.stringify({\n                live_history: allTranscriptionsRef.current,\n                finalized_chunk: message.message\n              })\n            });\n            const data = await response.json();\n            if (Array.isArray(data.merged)) {\n              setAllTranscriptions(data.merged);\n              // Mark all merged entries as finalized for feedback (simple: all entries are finalized after merge)\n              setFinalizedIndexes(data.merged.map((_, idx) => idx));\n            } else {\n              setAllTranscriptions([message.message, ...allTranscriptionsRef.current]);\n              setFinalizedIndexes([0]);\n            }\n          } catch (err) {\n            console.error('[MainTranscribe] Merge error:', err);\n            setAllTranscriptions(prev => {\n              if (prev.length === 0 || prev[0] !== message.message) {\n                setFinalizedIndexes([0]);\n                return [message.message, ...prev];\n              }\n              return prev;\n            });\n          }\n        }\n      } catch (e) {\n        console.warn('[MainTranscribe] Failed to parse message', event.data);\n      }\n    };\n    ws.onerror = err => {\n      console.error('[MainTranscribe] WebSocket error:', err);\n    };\n    ws.onclose = () => {\n      console.log('[MainTranscribe] WebSocket closed');\n    };\n    setMainTranscribeSocket(ws);\n    return () => {\n      console.log('ðŸ§¹ App component', componentId, 'unmounting, removing WebRTC listener');\n\n      // Clear any pending transcription timer\n      if (clearTranscriptionTimer.current) {\n        clearTimeout(clearTranscriptionTimer.current);\n      }\n      webRTCService.removeListener(handleWebRTCMessage);\n      // WebRTC streaming will stop automatically when no listeners remain\n\n      ws.close();\n    };\n  }, []); // Empty dependency array - only run once\n\n  useEffect(() => {\n    const key = localStorage.getItem('groq_api_key');\n    if (!key) setShowGroqModal(true);\n  }, []);\n  const handleSetGroqKey = key => {\n    setShowGroqModal(false);\n    // Optionally: trigger any logic that needs the key\n  };\n  const handleLanguageChange = language => {\n    setSelectedLanguage(language);\n    console.log('ðŸ”„ Language changed to:', language);\n    webRTCService.setLanguage(language); // Update WebRTC service with new language\n  };\n\n  // Reconnect handler for connection status click\n  const handleReconnect = () => {\n    console.log('ðŸ”„ Reconnecting WebRTC...');\n    webRTCService.forceCleanup();\n    setTimeout(() => {\n      webRTCService.startAudioStreaming();\n    }, 500); // Small delay to ensure cleanup\n  };\n  const handleTranscriptionToggle = () => {\n    if (isTranscribing) {\n      webRTCService.stopAudioStreaming();\n      setIsTranscribing(false);\n    } else {\n      webRTCService.startAudioStreaming();\n      setIsTranscribing(true);\n    }\n  };\n  useEffect(() => {\n    const cleaned = Array.from(new Set(allTranscriptions.map(t => typeof t === 'string' ? t.trim() : '').filter(Boolean)));\n    setCleanedTranscriptions(cleaned);\n  }, [allTranscriptions]);\n  useEffect(() => {\n    if (typeof taskSummary === 'string' && (taskSummary.toLowerCase().includes('check') || taskSummary.toLowerCase().includes('search')) && !showWebSearch) {\n      setShowWebSearch(true);\n    }\n  }, [taskSummary, showWebSearch]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [showGroqModal && /*#__PURE__*/_jsxDEV(GroqKeyModal, {\n      onSetKey: handleSetGroqKey\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 224,\n      columnNumber: 25\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: historyFullScreen ? 'fullscreen-history' : '',\n      children: [/*#__PURE__*/_jsxDEV(\"header\", {\n        className: \"App-header\",\n        children: /*#__PURE__*/_jsxDEV(TranscriptionDisplay, {\n          transcription: transcription,\n          allTranscriptions: allTranscriptions,\n          connectionStatus: connectionStatus,\n          imageUrls: imageUrls,\n          onLanguageChange: handleLanguageChange,\n          onReconnect: handleReconnect,\n          cleanedTranscriptions: cleanedTranscriptions,\n          historyFullScreen: historyFullScreen,\n          onToggleHistoryFullScreen: () => setHistoryFullScreen(v => !v),\n          isTranscribing: isTranscribing,\n          onTranscriptionToggle: handleTranscriptionToggle,\n          finalizedIndexes: finalizedIndexes // Pass to child\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 227,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 226,\n        columnNumber: 9\n      }, this), showWebSearch && /*#__PURE__*/_jsxDEV(WebSearchDisplay, {\n        taskSummary: taskSummary,\n        onClose: () => setShowWebSearch(false)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 243,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 225,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n}\n_s(App, \"3Lj4wP7M9/zwTsdN4OO4duSqdzU=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useRef","TranscriptionDisplay","TranscriptionHistory","webRTCService","WebSearchDisplay","GroqKeyModal","jsxDEV","_jsxDEV","Fragment","_Fragment","App","_s","transcription","setTranscription","allTranscriptions","setAllTranscriptions","imageUrls","setImageUrls","connectionStatus","setConnectionStatus","selectedLanguage","setSelectedLanguage","cleanedTranscriptions","setCleanedTranscriptions","historyFullScreen","setHistoryFullScreen","showWebSearch","setShowWebSearch","taskSummary","setTaskSummary","isTranscribing","setIsTranscribing","clearTranscriptionTimer","mainTranscribeSocket","setMainTranscribeSocket","finalizedIndexes","setFinalizedIndexes","showGroqModal","setShowGroqModal","allTranscriptionsRef","componentId","Math","random","toString","substring","console","log","handleWebRTCMessage","message","type","data","prev","chunkId","images","text","startsWith","length","transcriptionText","trim","includes","current","clearTimeout","setTimeout","addListener","ws","window","WebSocket","onopen","onmessage","event","JSON","parse","response","fetch","method","headers","body","stringify","live_history","finalized_chunk","json","Array","isArray","merged","map","_","idx","err","error","e","warn","onerror","onclose","removeListener","close","key","localStorage","getItem","handleSetGroqKey","handleLanguageChange","language","setLanguage","handleReconnect","forceCleanup","startAudioStreaming","handleTranscriptionToggle","stopAudioStreaming","cleaned","from","Set","t","filter","Boolean","toLowerCase","children","onSetKey","fileName","_jsxFileName","lineNumber","columnNumber","className","onLanguageChange","onReconnect","onToggleHistoryFullScreen","v","onTranscriptionToggle","onClose","_c","$RefreshReg$"],"sources":["/Users/tyler/Documents/spoken/frontend/src/App.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport TranscriptionDisplay from './components/TranscriptionDisplay/TranscriptionDisplay';\nimport TranscriptionHistory from './components/TranscriptionHistory/TranscriptionHistory';\nimport webRTCService from './WebRTCService';\nimport WebSearchDisplay from './components/WebSearchDisplay/WebSearchDisplay';\nimport GroqKeyModal from './components/GroqKeyModal';\n\nfunction App() {\n  const [transcription, setTranscription] = useState('');\n  const [allTranscriptions, setAllTranscriptions] = useState([]);\n  const [imageUrls, setImageUrls] = useState({});  // Store images by chunkId\n  const [connectionStatus, setConnectionStatus] = useState('Connecting...');\n  const [selectedLanguage, setSelectedLanguage] = useState('en'); // New state for language\n  const [cleanedTranscriptions, setCleanedTranscriptions] = useState([]); // NEW\n  const [historyFullScreen, setHistoryFullScreen] = useState(false);\n  const [showWebSearch, setShowWebSearch] = useState(false);\n  const [taskSummary, setTaskSummary] = useState('');\n  const [isTranscribing, setIsTranscribing] = useState(true);\n  const clearTranscriptionTimer = useRef(null);\n  const [mainTranscribeSocket, setMainTranscribeSocket] = useState(null);\n  const [finalizedIndexes, setFinalizedIndexes] = useState([]); // NEW: track finalized entries\n  const [showGroqModal, setShowGroqModal] = useState(false);\n  const allTranscriptionsRef = useRef(allTranscriptions);\n\n  useEffect(() => {\n    const componentId = Math.random().toString(36).substring(2, 11);\n    console.log('ðŸŽ¯ App component mounted with ID:', componentId, 'setting up WebRTC listener');\n    \n    const handleWebRTCMessage = (message) => {\n      console.log('[App] Received WebRTC message:', message); // Debug log\n      if (message.type === 'status') {\n        setConnectionStatus(message.data);\n      } else if (message.type === 'images') {\n        // Store images for the corresponding transcription\n        setImageUrls(prev => ({\n          ...prev,\n          [message.chunkId]: message.images\n        }));\n        console.log('ðŸ–¼ï¸ Received images for chunk:', message.chunkId, message.images);\n      } else if (message.type === 'history') {\n        // Real-time streaming chunk for history log\n        const text = message.message;\n        // Only add to history if it's not the default chunk sent message\n        if (!text.startsWith('audioData chunk sent')) {\n          setAllTranscriptions(prev => {\n            if (text && (prev.length === 0 || prev[0] !== text)) {\n              return [text, ...prev];\n            }\n            return prev;\n          });\n        }\n      } else if (message.type === 'summary') {\n        // 3-second chunk for summary\n        setCleanedTranscriptions(prev => {\n          const text = message.message;\n          if (text && (prev.length === 0 || prev[0] !== text)) {\n            return [text, ...prev];\n          }\n          return prev;\n        });\n      } else if (message.type === 'transcription') {\n        console.log('[App] Received transcription message.data:', message.data); // Debug log\n        const transcriptionText = message.data;\n        \n        // Only update transcription if it's meaningful (not empty or \"No speech detected\")\n        if (transcriptionText && \n            transcriptionText.trim() !== '' && \n            transcriptionText !== '[No speech detected]' &&\n            !transcriptionText.includes('[Transcription error:')) {\n          \n          console.log('âœ… Updating live transcription:', transcriptionText);\n          setTranscription(transcriptionText);\n          \n          // Clear any existing timer\n          if (clearTranscriptionTimer.current) {\n            clearTimeout(clearTranscriptionTimer.current);\n          }\n          \n          // Set a new timer to clear the transcription after 5 seconds of silence\n          clearTranscriptionTimer.current = setTimeout(() => {\n            console.log('â° Clearing transcription after timeout');\n            setTranscription('');\n          }, 5000);\n          \n          // Add to history only if it's different from the last one\n          setAllTranscriptions(prev => {\n            if (prev.length === 0 || prev[0] !== transcriptionText) {\n              return [transcriptionText, ...prev];\n            }\n            return prev;\n          });\n        } else {\n          console.log('ðŸ”‡ Ignoring empty/error transcription:', transcriptionText);\n          // Don't update live transcription - keep the previous one visible\n        }\n      }\n    };\n\n    // Add listener - WebRTC streaming will start automatically\n    webRTCService.addListener(handleWebRTCMessage);\n\n    // Setup main-transcribe WebSocket for finalized history\n    const ws = new window.WebSocket('ws://localhost:8000/main-transcribe');\n    ws.onopen = () => {\n      console.log('[MainTranscribe] Connected to /main-transcribe');\n    };\n    ws.onmessage = async (event) => {\n      try {\n        const message = JSON.parse(event.data);\n        if (message.type === 'history' && message.message) {\n          // Call backend to merge live and finalized history using LLM\n          try {\n            const response = await fetch('http://localhost:8000/merge-history', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({\n                live_history: allTranscriptionsRef.current,\n                finalized_chunk: message.message\n              })\n            });\n            const data = await response.json();\n            if (Array.isArray(data.merged)) {\n              setAllTranscriptions(data.merged);\n              // Mark all merged entries as finalized for feedback (simple: all entries are finalized after merge)\n              setFinalizedIndexes(data.merged.map((_, idx) => idx));\n            } else {\n              setAllTranscriptions([message.message, ...allTranscriptionsRef.current]);\n              setFinalizedIndexes([0]);\n            }\n          } catch (err) {\n            console.error('[MainTranscribe] Merge error:', err);\n            setAllTranscriptions(prev => {\n              if (prev.length === 0 || prev[0] !== message.message) {\n                setFinalizedIndexes([0]);\n                return [message.message, ...prev];\n              }\n              return prev;\n            });\n          }\n        }\n      } catch (e) {\n        console.warn('[MainTranscribe] Failed to parse message', event.data);\n      }\n    };\n    ws.onerror = (err) => {\n      console.error('[MainTranscribe] WebSocket error:', err);\n    };\n    ws.onclose = () => {\n      console.log('[MainTranscribe] WebSocket closed');\n    };\n    setMainTranscribeSocket(ws);\n\n    return () => {\n      console.log('ðŸ§¹ App component', componentId, 'unmounting, removing WebRTC listener');\n      \n      // Clear any pending transcription timer\n      if (clearTranscriptionTimer.current) {\n        clearTimeout(clearTranscriptionTimer.current);\n      }\n      \n      webRTCService.removeListener(handleWebRTCMessage);\n      // WebRTC streaming will stop automatically when no listeners remain\n\n      ws.close();\n    };\n  }, []); // Empty dependency array - only run once\n\n  useEffect(() => {\n    const key = localStorage.getItem('groq_api_key');\n    if (!key) setShowGroqModal(true);\n  }, []);\n\n  const handleSetGroqKey = (key) => {\n    setShowGroqModal(false);\n    // Optionally: trigger any logic that needs the key\n  };\n\n  const handleLanguageChange = (language) => {\n    setSelectedLanguage(language);\n    console.log('ðŸ”„ Language changed to:', language);\n    webRTCService.setLanguage(language); // Update WebRTC service with new language\n  };\n\n  // Reconnect handler for connection status click\n  const handleReconnect = () => {\n    console.log('ðŸ”„ Reconnecting WebRTC...');\n    webRTCService.forceCleanup();\n    setTimeout(() => {\n      webRTCService.startAudioStreaming();\n    }, 500); // Small delay to ensure cleanup\n  };\n\n  const handleTranscriptionToggle = () => {\n    if (isTranscribing) {\n      webRTCService.stopAudioStreaming();\n      setIsTranscribing(false);\n    } else {\n      webRTCService.startAudioStreaming();\n      setIsTranscribing(true);\n    }\n  };\n\n  useEffect(() => {\n    const cleaned = Array.from(new Set(\n      allTranscriptions\n        .map(t => (typeof t === 'string' ? t.trim() : ''))\n        .filter(Boolean)\n    ));\n    setCleanedTranscriptions(cleaned);\n  }, [allTranscriptions]);\n\n  useEffect(() => {\n    if (\n      typeof taskSummary === 'string' &&\n      (taskSummary.toLowerCase().includes('check') || taskSummary.toLowerCase().includes('search')) &&\n      !showWebSearch\n    ) {\n      setShowWebSearch(true);\n    }\n  }, [taskSummary, showWebSearch]);\n\n  return (\n    <>\n      {showGroqModal && <GroqKeyModal onSetKey={handleSetGroqKey} />}\n      <div className={historyFullScreen ? 'fullscreen-history' : ''}>\n        <header className=\"App-header\">\n          <TranscriptionDisplay\n            transcription={transcription}\n            allTranscriptions={allTranscriptions}\n            connectionStatus={connectionStatus}\n            imageUrls={imageUrls}\n            onLanguageChange={handleLanguageChange}\n            onReconnect={handleReconnect}\n            cleanedTranscriptions={cleanedTranscriptions}\n            historyFullScreen={historyFullScreen}\n            onToggleHistoryFullScreen={() => setHistoryFullScreen(v => !v)}\n            isTranscribing={isTranscribing}\n            onTranscriptionToggle={handleTranscriptionToggle}\n            finalizedIndexes={finalizedIndexes} // Pass to child\n          />\n        </header>\n        {showWebSearch && (\n          <WebSearchDisplay\n            taskSummary={taskSummary}\n            onClose={() => setShowWebSearch(false)}\n          />\n        )}\n      </div>\n    </>\n  );\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}