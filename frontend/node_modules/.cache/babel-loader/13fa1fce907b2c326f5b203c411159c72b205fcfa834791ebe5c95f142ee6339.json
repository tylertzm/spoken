{"ast":null,"code":"import React,{useState,useEffect,useRef}from'react';import'./styles.css';import TranscriptionDisplay from'./TranscriptionDisplay';import webRTCService from'./WebRTCService';import{jsx as _jsx}from\"react/jsx-runtime\";function App(){const[transcription,setTranscription]=useState('');const[allTranscriptions,setAllTranscriptions]=useState([]);const[connectionStatus,setConnectionStatus]=useState('Connecting...');const clearTranscriptionTimer=useRef(null);useEffect(()=>{const componentId=Math.random().toString(36).substring(2,11);console.log('🎯 App component mounted with ID:',componentId,'setting up WebRTC listener');const handleWebRTCMessage=message=>{console.log('📨 Component',componentId,'received WebRTC message:',message);if(message.type==='status'){setConnectionStatus(message.data);}else if(message.type==='transcription'){const transcriptionText=message.data;// Only update transcription if it's meaningful (not empty or \"No speech detected\")\nif(transcriptionText&&transcriptionText.trim()!==''&&transcriptionText!=='[No speech detected]'&&!transcriptionText.includes('[Transcription error:')){console.log('✅ Updating live transcription:',transcriptionText);setTranscription(transcriptionText);// Clear any existing timer\nif(clearTranscriptionTimer.current){clearTimeout(clearTranscriptionTimer.current);}// Set a new timer to clear the transcription after 5 seconds of silence\nclearTranscriptionTimer.current=setTimeout(()=>{console.log('⏰ Clearing transcription after timeout');setTranscription('');},5000);// Add to history only if it's different from the last one\nsetAllTranscriptions(prev=>{if(prev.length===0||prev[0]!==transcriptionText){return[transcriptionText,...prev];}return prev;});}else{console.log('🔇 Ignoring empty/error transcription:',transcriptionText);// Don't update live transcription - keep the previous one visible\n}}};// Add listener - WebRTC streaming will start automatically\nwebRTCService.addListener(handleWebRTCMessage);return()=>{console.log('🧹 App component',componentId,'unmounting, removing WebRTC listener');// Clear any pending transcription timer\nif(clearTranscriptionTimer.current){clearTimeout(clearTranscriptionTimer.current);}webRTCService.removeListener(handleWebRTCMessage);// WebRTC streaming will stop automatically when no listeners remain\n};},[]);// Empty dependency array - only run once\nreturn/*#__PURE__*/_jsx(\"div\",{className:\"App\",children:/*#__PURE__*/_jsx(\"header\",{className:\"App-header\",children:/*#__PURE__*/_jsx(TranscriptionDisplay,{transcription:transcription,allTranscriptions:allTranscriptions,connectionStatus:connectionStatus})})});}export default App;","map":{"version":3,"names":["React","useState","useEffect","useRef","TranscriptionDisplay","webRTCService","jsx","_jsx","App","transcription","setTranscription","allTranscriptions","setAllTranscriptions","connectionStatus","setConnectionStatus","clearTranscriptionTimer","componentId","Math","random","toString","substring","console","log","handleWebRTCMessage","message","type","data","transcriptionText","trim","includes","current","clearTimeout","setTimeout","prev","length","addListener","removeListener","className","children"],"sources":["/Users/tyler/Documents/SpeakNow/frontend/src/App.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport './styles.css';\nimport TranscriptionDisplay from './TranscriptionDisplay';\nimport webRTCService from './WebRTCService';\n\nfunction App() {\n  const [transcription, setTranscription] = useState('');\n  const [allTranscriptions, setAllTranscriptions] = useState([]);\n  const [connectionStatus, setConnectionStatus] = useState('Connecting...');\n  const clearTranscriptionTimer = useRef(null);\n\n  useEffect(() => {\n    const componentId = Math.random().toString(36).substring(2, 11);\n    console.log('🎯 App component mounted with ID:', componentId, 'setting up WebRTC listener');\n    \n    const handleWebRTCMessage = (message) => {\n      console.log('📨 Component', componentId, 'received WebRTC message:', message);\n      if (message.type === 'status') {\n        setConnectionStatus(message.data);\n      } else if (message.type === 'transcription') {\n        const transcriptionText = message.data;\n        \n        // Only update transcription if it's meaningful (not empty or \"No speech detected\")\n        if (transcriptionText && \n            transcriptionText.trim() !== '' && \n            transcriptionText !== '[No speech detected]' &&\n            !transcriptionText.includes('[Transcription error:')) {\n          \n          console.log('✅ Updating live transcription:', transcriptionText);\n          setTranscription(transcriptionText);\n          \n          // Clear any existing timer\n          if (clearTranscriptionTimer.current) {\n            clearTimeout(clearTranscriptionTimer.current);\n          }\n          \n          // Set a new timer to clear the transcription after 5 seconds of silence\n          clearTranscriptionTimer.current = setTimeout(() => {\n            console.log('⏰ Clearing transcription after timeout');\n            setTranscription('');\n          }, 5000);\n          \n          // Add to history only if it's different from the last one\n          setAllTranscriptions(prev => {\n            if (prev.length === 0 || prev[0] !== transcriptionText) {\n              return [transcriptionText, ...prev];\n            }\n            return prev;\n          });\n        } else {\n          console.log('🔇 Ignoring empty/error transcription:', transcriptionText);\n          // Don't update live transcription - keep the previous one visible\n        }\n      }\n    };\n\n    // Add listener - WebRTC streaming will start automatically\n    webRTCService.addListener(handleWebRTCMessage);\n\n    return () => {\n      console.log('🧹 App component', componentId, 'unmounting, removing WebRTC listener');\n      \n      // Clear any pending transcription timer\n      if (clearTranscriptionTimer.current) {\n        clearTimeout(clearTranscriptionTimer.current);\n      }\n      \n      webRTCService.removeListener(handleWebRTCMessage);\n      // WebRTC streaming will stop automatically when no listeners remain\n    };\n  }, []); // Empty dependency array - only run once\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <TranscriptionDisplay\n          transcription={transcription}\n          allTranscriptions={allTranscriptions}\n          connectionStatus={connectionStatus}\n        />\n      </header>\n    </div>\n  );\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}