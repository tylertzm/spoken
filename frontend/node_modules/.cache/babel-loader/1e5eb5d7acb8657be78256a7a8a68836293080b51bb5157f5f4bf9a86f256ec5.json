{"ast":null,"code":"// PollingService.js - Alternative to WebSocket using HTTP polling\nclass PollingService {\n  constructor() {\n    this.listeners = new Set();\n    this.polling = false;\n    this.pollInterval = null;\n    this.consecutiveErrors = 0;\n    this.lastSuccessTime = null;\n  }\n  addListener(callback) {\n    this.listeners.add(callback);\n\n    // Start polling when first listener is added\n    if (this.listeners.size === 1 && !this.polling) {\n      this.startPolling();\n    }\n  }\n  removeListener(callback) {\n    this.listeners.delete(callback);\n\n    // Stop polling when no listeners remain\n    if (this.listeners.size === 0) {\n      this.stopPolling();\n    }\n  }\n  notifyListeners(message) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(message);\n      } catch (error) {\n        console.error('Error in polling listener:', error);\n      }\n    });\n  }\n  async startPolling() {\n    if (this.polling) return;\n    console.log('üîÑ Starting transcription polling...');\n    this.polling = true;\n    this.notifyListeners({\n      type: 'status',\n      data: 'Connecting...'\n    });\n    const poll = async () => {\n      if (!this.polling) return;\n      try {\n        const response = await fetch('http://localhost:8000/');\n        if (!response.ok) {\n          throw new Error(`HTTP ${response.status}`);\n        }\n        const data = await response.json();\n\n        // Update status to show successful connection\n        this.notifyListeners({\n          type: 'status',\n          data: 'Connected ‚úÖ'\n        });\n\n        // Only process non-empty transcriptions\n        if (data.text && data.text.trim()) {\n          console.log('üì• Received new transcription:', data.text);\n          this.notifyListeners({\n            type: 'transcription',\n            data: data.text\n          });\n        }\n      } catch (error) {\n        console.error('‚ùå Polling error:', error);\n        this.notifyListeners({\n          type: 'status',\n          data: `Error: ${error.message} ‚ùå`\n        });\n      }\n\n      // Poll every 50ms for faster real-time updates\n      if (this.polling) {\n        setTimeout(poll, 50);\n      }\n    };\n    poll();\n  }\n  stopPolling() {\n    console.log('üõë Stopping transcription polling...');\n    this.polling = false;\n    if (this.pollInterval) {\n      clearTimeout(this.pollInterval);\n      this.pollInterval = null;\n    }\n    this.notifyListeners({\n      type: 'status',\n      data: 'Disconnected ‚ùå'\n    });\n  }\n\n  // Force cleanup - useful for debugging\n  forceCleanup() {\n    console.log('üî• Force cleanup: clearing all listeners and stopping polling');\n    this.listeners.clear();\n    this.stopPolling();\n  }\n}\n\n// Create singleton instance\nconst pollingService = new PollingService();\n\n// Make it available globally for debugging\nif (typeof window !== 'undefined') {\n  window.pollingService = pollingService;\n  console.log('üîß PollingService available globally as window.pollingService');\n}\nexport default pollingService;","map":{"version":3,"names":["PollingService","constructor","listeners","Set","polling","pollInterval","consecutiveErrors","lastSuccessTime","addListener","callback","add","size","startPolling","removeListener","delete","stopPolling","notifyListeners","message","forEach","error","console","log","type","data","poll","response","fetch","ok","Error","status","json","text","trim","setTimeout","clearTimeout","forceCleanup","clear","pollingService","window"],"sources":["/Users/tyler/Documents/SpeakNow/frontend/src/PollingService.js"],"sourcesContent":["// PollingService.js - Alternative to WebSocket using HTTP polling\nclass PollingService {\n  constructor() {\n    this.listeners = new Set();\n    this.polling = false;\n    this.pollInterval = null;\n    this.consecutiveErrors = 0;\n    this.lastSuccessTime = null;\n  }\n\n  addListener(callback) {\n    this.listeners.add(callback);\n    \n    // Start polling when first listener is added\n    if (this.listeners.size === 1 && !this.polling) {\n      this.startPolling();\n    }\n  }\n\n  removeListener(callback) {\n    this.listeners.delete(callback);\n    \n    // Stop polling when no listeners remain\n    if (this.listeners.size === 0) {\n      this.stopPolling();\n    }\n  }\n\n  notifyListeners(message) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(message);\n      } catch (error) {\n        console.error('Error in polling listener:', error);\n      }\n    });\n  }\n\n  async startPolling() {\n    if (this.polling) return;\n    \n    console.log('üîÑ Starting transcription polling...');\n    this.polling = true;\n    \n    this.notifyListeners({ type: 'status', data: 'Connecting...' });\n    \n    const poll = async () => {\n      if (!this.polling) return;\n      \n      try {\n        const response = await fetch('http://localhost:8000/');\n        \n        if (!response.ok) {\n          throw new Error(`HTTP ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        // Update status to show successful connection\n        this.notifyListeners({ type: 'status', data: 'Connected ‚úÖ' });\n        \n        // Only process non-empty transcriptions\n        if (data.text && data.text.trim()) {\n          console.log('üì• Received new transcription:', data.text);\n          this.notifyListeners({ type: 'transcription', data: data.text });\n        }\n      } catch (error) {\n        console.error('‚ùå Polling error:', error);\n        this.notifyListeners({ type: 'status', data: `Error: ${error.message} ‚ùå` });\n      }\n      \n      // Poll every 50ms for faster real-time updates\n      if (this.polling) {\n        setTimeout(poll, 50);\n      }\n    };\n    \n    poll();\n  }\n\n  stopPolling() {\n    console.log('üõë Stopping transcription polling...');\n    this.polling = false;\n    \n    if (this.pollInterval) {\n      clearTimeout(this.pollInterval);\n      this.pollInterval = null;\n    }\n    \n    this.notifyListeners({ type: 'status', data: 'Disconnected ‚ùå' });\n  }\n\n  // Force cleanup - useful for debugging\n  forceCleanup() {\n    console.log('üî• Force cleanup: clearing all listeners and stopping polling');\n    this.listeners.clear();\n    this.stopPolling();\n  }\n}\n\n// Create singleton instance\nconst pollingService = new PollingService();\n\n// Make it available globally for debugging\nif (typeof window !== 'undefined') {\n  window.pollingService = pollingService;\n  console.log('üîß PollingService available globally as window.pollingService');\n}\n\nexport default pollingService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}