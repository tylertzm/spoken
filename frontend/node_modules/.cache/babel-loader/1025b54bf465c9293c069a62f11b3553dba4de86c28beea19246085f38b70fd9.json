{"ast":null,"code":"// WebRTCService.js - Real-time audio streaming with WebRTC\nclass WebRTCService {\n  constructor() {\n    this.listeners = new Set();\n    this.isStreaming = false;\n    this.mediaStream = null;\n    this.peerConnection = null;\n    this.dataChannel = null;\n    this.audioContext = null;\n    this.mediaRecorder = null;\n  }\n  addListener(callback) {\n    this.listeners.add(callback);\n\n    // Start streaming when first listener is added\n    if (this.listeners.size === 1 && !this.isStreaming) {\n      this.startAudioStreaming();\n    }\n  }\n  removeListener(callback) {\n    this.listeners.delete(callback);\n\n    // Stop streaming when no listeners remain\n    if (this.listeners.size === 0) {\n      this.stopAudioStreaming();\n    }\n  }\n  notifyListeners(message) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(message);\n      } catch (error) {\n        console.error('Error in WebRTC listener:', error);\n      }\n    });\n  }\n  async startAudioStreaming() {\n    if (this.isStreaming) return;\n    try {\n      console.log('üéôÔ∏è Starting WebRTC audio streaming...');\n      this.notifyListeners({\n        type: 'status',\n        data: 'Starting audio...'\n      });\n\n      // Get microphone access with specific constraints for better compatibility\n      this.mediaStream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true,\n          sampleRate: 16000,\n          channelCount: 1 // Mono audio\n        }\n      });\n      console.log('üé§ Microphone access granted');\n      this.notifyListeners({\n        type: 'status',\n        data: 'Microphone ready ‚úÖ'\n      });\n\n      // Create WebSocket connection for signaling\n      await this.createWebSocketConnection();\n\n      // Set up audio processing with Web Audio API for better control\n      await this.setupWebAudioProcessing();\n      this.isStreaming = true;\n      console.log('üöÄ WebRTC audio streaming started');\n    } catch (error) {\n      console.error('‚ùå Failed to start audio streaming:', error);\n      this.notifyListeners({\n        type: 'status',\n        data: `Error: ${error.message} ‚ùå`\n      });\n    }\n  }\n  async createWebSocketConnection() {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket('ws://localhost:8001/webrtc');\n      ws.onopen = () => {\n        console.log('üì° WebSocket connected');\n        this.signalingSocket = ws;\n        this.notifyListeners({\n          type: 'status',\n          data: 'Connected ‚úÖ'\n        });\n        ws.onmessage = event => {\n          try {\n            const data = JSON.parse(event.data);\n            if (data.type === 'transcription') {\n              console.log('üì• Received transcription:', data.text);\n              this.notifyListeners({\n                type: 'transcription',\n                data: data.text\n              });\n            } else if (data.type === 'status') {\n              console.log('üìä Status update:', data.message);\n              this.notifyListeners({\n                type: 'status',\n                data: data.message\n              });\n            }\n          } catch (error) {\n            console.error('‚ùå Error parsing WebSocket message:', error);\n          }\n        };\n        resolve();\n      };\n      ws.onerror = error => {\n        console.error('‚ùå WebSocket error:', error);\n        this.notifyListeners({\n          type: 'status',\n          data: 'Connection error ‚ùå'\n        });\n        reject(error);\n      };\n      ws.onclose = event => {\n        console.log('üì° WebSocket disconnected:', event.code, event.reason);\n        this.signalingSocket = null;\n        this.notifyListeners({\n          type: 'status',\n          data: 'Disconnected ‚ùå'\n        });\n\n        // Don't automatically reconnect to avoid connection loops\n        // The component will restart the connection when needed\n      };\n    });\n  }\n  async setupWebAudioProcessing() {\n    try {\n      // Create AudioContext for raw audio processing\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)({\n        sampleRate: 16000\n      });\n\n      // Load the AudioWorklet processor with cache busting\n      const processorUrl = `/audio-processor.js?v=${Date.now()}`;\n      await this.audioContext.audioWorklet.addModule(processorUrl);\n\n      // Create source node from microphone stream\n      const source = this.audioContext.createMediaStreamSource(this.mediaStream);\n\n      // Create AudioWorkletNode for raw audio data processing\n      this.processor = new AudioWorkletNode(this.audioContext, 'audio-processor');\n\n      // Listen for processed audio data from the worklet\n      this.processor.port.onmessage = event => {\n        var _this$signalingSocket, _this$signalingSocket2;\n        if (event.data.type === 'audioData' && ((_this$signalingSocket = this.signalingSocket) === null || _this$signalingSocket === void 0 ? void 0 : _this$signalingSocket.readyState) === WebSocket.OPEN) {\n          // Send real-time audio chunks for streaming\n          if (event.data.realtime) {\n            const pcmBuffer = event.data.data;\n            const sampleCount = event.data.sampleCount || 4096;\n            console.log(`üéµ Sending real-time PCM audio: ${pcmBuffer.byteLength} bytes (${sampleCount} samples)`);\n            this.signalingSocket.send(pcmBuffer);\n          }\n        } else if (event.data.type === 'transcriptionChunk' && ((_this$signalingSocket2 = this.signalingSocket) === null || _this$signalingSocket2 === void 0 ? void 0 : _this$signalingSocket2.readyState) === WebSocket.OPEN) {\n          // Send 3-second chunks for transcription\n          const pcmBuffer = event.data.data;\n          const duration = event.data.duration;\n          const chunkId = event.data.chunkId;\n          console.log(`üé§ Sending transcription chunk ${chunkId}: ${pcmBuffer.byteLength} bytes, ${duration.toFixed(2)}s`);\n\n          // Send metadata first, then audio data\n          const message = JSON.stringify({\n            type: 'transcriptionChunk',\n            chunkId: chunkId,\n            duration: duration,\n            sampleCount: event.data.sampleCount\n          });\n          this.signalingSocket.send(message);\n          this.signalingSocket.send(pcmBuffer);\n        }\n      };\n\n      // Connect the audio processing chain\n      source.connect(this.processor);\n      this.processor.connect(this.audioContext.destination);\n      console.log('üî¥ AudioWorklet processing started');\n      this.notifyListeners({\n        type: 'status',\n        data: 'Recording with AudioWorklet... üî¥'\n      });\n    } catch (error) {\n      console.error('‚ùå Failed to setup AudioWorklet:', error);\n      // Fallback to ScriptProcessorNode if AudioWorklet fails\n      this.setupFallbackAudioProcessing();\n    }\n  }\n  setupFallbackAudioProcessing() {\n    console.log('‚ö†Ô∏è Falling back to ScriptProcessorNode (deprecated)');\n\n    // Create source node from microphone stream\n    const source = this.audioContext.createMediaStreamSource(this.mediaStream);\n\n    // Create ScriptProcessorNode for raw audio data\n    const bufferSize = 4096;\n    this.processor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);\n    this.processor.onaudioprocess = event => {\n      var _this$signalingSocket3;\n      if (((_this$signalingSocket3 = this.signalingSocket) === null || _this$signalingSocket3 === void 0 ? void 0 : _this$signalingSocket3.readyState) === WebSocket.OPEN) {\n        const inputBuffer = event.inputBuffer;\n        const inputData = inputBuffer.getChannelData(0); // Get mono channel\n\n        // Convert Float32Array to Int16Array (PCM 16-bit)\n        const pcmData = new Int16Array(inputData.length);\n        for (let i = 0; i < inputData.length; i++) {\n          // Convert from -1.0 to 1.0 range to -32768 to 32767 range\n          const sample = Math.max(-1, Math.min(1, inputData[i]));\n          pcmData[i] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;\n        }\n\n        // Send raw PCM data\n        console.log('üéµ Sending PCM audio chunk (fallback):', pcmData.length, 'samples');\n        this.signalingSocket.send(pcmData.buffer);\n      }\n    };\n\n    // Connect the audio processing chain\n    source.connect(this.processor);\n    this.processor.connect(this.audioContext.destination);\n    console.log('üî¥ Fallback audio processing started');\n    this.notifyListeners({\n      type: 'status',\n      data: 'Recording (fallback mode)... üî¥'\n    });\n  }\n  stopAudioStreaming() {\n    console.log('üõë Stopping WebRTC audio streaming...');\n    this.isStreaming = false;\n\n    // Stop audio processing\n    if (this.processor) {\n      this.processor.disconnect();\n\n      // Clean up AudioWorkletNode port if it exists\n      if (this.processor.port) {\n        this.processor.port.onmessage = null;\n      }\n      this.processor = null;\n    }\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n\n    // Close WebSocket\n    if (this.signalingSocket) {\n      this.signalingSocket.close();\n      this.signalingSocket = null;\n    }\n\n    // Stop media stream\n    if (this.mediaStream) {\n      this.mediaStream.getTracks().forEach(track => track.stop());\n      this.mediaStream = null;\n    }\n    this.notifyListeners({\n      type: 'status',\n      data: 'Stopped ‚èπÔ∏è'\n    });\n    console.log('‚úÖ WebRTC audio streaming stopped');\n  }\n\n  // Force cleanup - useful for debugging\n  forceCleanup() {\n    console.log('üî• Force cleanup: clearing all listeners and stopping streaming');\n    this.listeners.clear();\n    this.stopAudioStreaming();\n  }\n}\n\n// Create singleton instance\nconst webRTCService = new WebRTCService();\n\n// Make it available globally for debugging\nif (typeof window !== 'undefined') {\n  window.webRTCService = webRTCService;\n  console.log('üîß WebRTCService available globally as window.webRTCService');\n}\nexport default webRTCService;","map":{"version":3,"names":["WebRTCService","constructor","listeners","Set","isStreaming","mediaStream","peerConnection","dataChannel","audioContext","mediaRecorder","addListener","callback","add","size","startAudioStreaming","removeListener","delete","stopAudioStreaming","notifyListeners","message","forEach","error","console","log","type","data","navigator","mediaDevices","getUserMedia","audio","echoCancellation","noiseSuppression","autoGainControl","sampleRate","channelCount","createWebSocketConnection","setupWebAudioProcessing","Promise","resolve","reject","ws","WebSocket","onopen","signalingSocket","onmessage","event","JSON","parse","text","onerror","onclose","code","reason","window","AudioContext","webkitAudioContext","processorUrl","Date","now","audioWorklet","addModule","source","createMediaStreamSource","processor","AudioWorkletNode","port","_this$signalingSocket","_this$signalingSocket2","readyState","OPEN","realtime","pcmBuffer","sampleCount","byteLength","send","duration","chunkId","toFixed","stringify","connect","destination","setupFallbackAudioProcessing","bufferSize","createScriptProcessor","onaudioprocess","_this$signalingSocket3","inputBuffer","inputData","getChannelData","pcmData","Int16Array","length","i","sample","Math","max","min","buffer","disconnect","close","getTracks","track","stop","forceCleanup","clear","webRTCService"],"sources":["/Users/tyler/Documents/SpeakNow/frontend/src/WebRTCService.js"],"sourcesContent":["// WebRTCService.js - Real-time audio streaming with WebRTC\nclass WebRTCService {\n  constructor() {\n    this.listeners = new Set();\n    this.isStreaming = false;\n    this.mediaStream = null;\n    this.peerConnection = null;\n    this.dataChannel = null;\n    this.audioContext = null;\n    this.mediaRecorder = null;\n  }\n\n  addListener(callback) {\n    this.listeners.add(callback);\n    \n    // Start streaming when first listener is added\n    if (this.listeners.size === 1 && !this.isStreaming) {\n      this.startAudioStreaming();\n    }\n  }\n\n  removeListener(callback) {\n    this.listeners.delete(callback);\n    \n    // Stop streaming when no listeners remain\n    if (this.listeners.size === 0) {\n      this.stopAudioStreaming();\n    }\n  }\n\n  notifyListeners(message) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(message);\n      } catch (error) {\n        console.error('Error in WebRTC listener:', error);\n      }\n    });\n  }\n\n  async startAudioStreaming() {\n    if (this.isStreaming) return;\n\n    try {\n      console.log('üéôÔ∏è Starting WebRTC audio streaming...');\n      this.notifyListeners({ type: 'status', data: 'Starting audio...' });\n\n      // Get microphone access with specific constraints for better compatibility\n      this.mediaStream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true,\n          sampleRate: 16000,\n          channelCount: 1  // Mono audio\n        }\n      });\n\n      console.log('üé§ Microphone access granted');\n      this.notifyListeners({ type: 'status', data: 'Microphone ready ‚úÖ' });\n\n      // Create WebSocket connection for signaling\n      await this.createWebSocketConnection();\n\n      // Set up audio processing with Web Audio API for better control\n      await this.setupWebAudioProcessing();\n\n      this.isStreaming = true;\n      console.log('üöÄ WebRTC audio streaming started');\n\n    } catch (error) {\n      console.error('‚ùå Failed to start audio streaming:', error);\n      this.notifyListeners({ type: 'status', data: `Error: ${error.message} ‚ùå` });\n    }\n  }\n\n  async createWebSocketConnection() {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket('ws://localhost:8001/webrtc');\n      \n      ws.onopen = () => {\n        console.log('üì° WebSocket connected');\n        this.signalingSocket = ws;\n        this.notifyListeners({ type: 'status', data: 'Connected ‚úÖ' });\n        \n        ws.onmessage = (event) => {\n          try {\n            const data = JSON.parse(event.data);\n            if (data.type === 'transcription') {\n              console.log('üì• Received transcription:', data.text);\n              this.notifyListeners({ type: 'transcription', data: data.text });\n            } else if (data.type === 'status') {\n              console.log('üìä Status update:', data.message);\n              this.notifyListeners({ type: 'status', data: data.message });\n            }\n          } catch (error) {\n            console.error('‚ùå Error parsing WebSocket message:', error);\n          }\n        };\n        \n        resolve();\n      };\n      \n      ws.onerror = (error) => {\n        console.error('‚ùå WebSocket error:', error);\n        this.notifyListeners({ type: 'status', data: 'Connection error ‚ùå' });\n        reject(error);\n      };\n      \n      ws.onclose = (event) => {\n        console.log('üì° WebSocket disconnected:', event.code, event.reason);\n        this.signalingSocket = null;\n        this.notifyListeners({ type: 'status', data: 'Disconnected ‚ùå' });\n        \n        // Don't automatically reconnect to avoid connection loops\n        // The component will restart the connection when needed\n      };\n    });\n  }\n\n  async setupWebAudioProcessing() {\n    try {\n      // Create AudioContext for raw audio processing\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)({\n        sampleRate: 16000\n      });\n      \n      // Load the AudioWorklet processor with cache busting\n      const processorUrl = `/audio-processor.js?v=${Date.now()}`;\n      await this.audioContext.audioWorklet.addModule(processorUrl);\n      \n      // Create source node from microphone stream\n      const source = this.audioContext.createMediaStreamSource(this.mediaStream);\n      \n      // Create AudioWorkletNode for raw audio data processing\n      this.processor = new AudioWorkletNode(this.audioContext, 'audio-processor');\n      \n      // Listen for processed audio data from the worklet\n      this.processor.port.onmessage = (event) => {\n        if (event.data.type === 'audioData' && this.signalingSocket?.readyState === WebSocket.OPEN) {\n          // Send real-time audio chunks for streaming\n          if (event.data.realtime) {\n            const pcmBuffer = event.data.data;\n            const sampleCount = event.data.sampleCount || 4096;\n            console.log(`üéµ Sending real-time PCM audio: ${pcmBuffer.byteLength} bytes (${sampleCount} samples)`);\n            this.signalingSocket.send(pcmBuffer);\n          }\n        } else if (event.data.type === 'transcriptionChunk' && this.signalingSocket?.readyState === WebSocket.OPEN) {\n          // Send 3-second chunks for transcription\n          const pcmBuffer = event.data.data;\n          const duration = event.data.duration;\n          const chunkId = event.data.chunkId;\n          console.log(`üé§ Sending transcription chunk ${chunkId}: ${pcmBuffer.byteLength} bytes, ${duration.toFixed(2)}s`);\n          \n          // Send metadata first, then audio data\n          const message = JSON.stringify({\n            type: 'transcriptionChunk',\n            chunkId: chunkId,\n            duration: duration,\n            sampleCount: event.data.sampleCount\n          });\n          this.signalingSocket.send(message);\n          this.signalingSocket.send(pcmBuffer);\n        }\n      };\n      \n      // Connect the audio processing chain\n      source.connect(this.processor);\n      this.processor.connect(this.audioContext.destination);\n      \n      console.log('üî¥ AudioWorklet processing started');\n      this.notifyListeners({ type: 'status', data: 'Recording with AudioWorklet... üî¥' });\n      \n    } catch (error) {\n      console.error('‚ùå Failed to setup AudioWorklet:', error);\n      // Fallback to ScriptProcessorNode if AudioWorklet fails\n      this.setupFallbackAudioProcessing();\n    }\n  }\n\n  setupFallbackAudioProcessing() {\n    console.log('‚ö†Ô∏è Falling back to ScriptProcessorNode (deprecated)');\n    \n    // Create source node from microphone stream\n    const source = this.audioContext.createMediaStreamSource(this.mediaStream);\n    \n    // Create ScriptProcessorNode for raw audio data\n    const bufferSize = 4096;\n    this.processor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);\n    \n    this.processor.onaudioprocess = (event) => {\n      if (this.signalingSocket?.readyState === WebSocket.OPEN) {\n        const inputBuffer = event.inputBuffer;\n        const inputData = inputBuffer.getChannelData(0); // Get mono channel\n        \n        // Convert Float32Array to Int16Array (PCM 16-bit)\n        const pcmData = new Int16Array(inputData.length);\n        for (let i = 0; i < inputData.length; i++) {\n          // Convert from -1.0 to 1.0 range to -32768 to 32767 range\n          const sample = Math.max(-1, Math.min(1, inputData[i]));\n          pcmData[i] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;\n        }\n        \n        // Send raw PCM data\n        console.log('üéµ Sending PCM audio chunk (fallback):', pcmData.length, 'samples');\n        this.signalingSocket.send(pcmData.buffer);\n      }\n    };\n    \n    // Connect the audio processing chain\n    source.connect(this.processor);\n    this.processor.connect(this.audioContext.destination);\n    \n    console.log('üî¥ Fallback audio processing started');\n    this.notifyListeners({ type: 'status', data: 'Recording (fallback mode)... üî¥' });\n  }\n\n  stopAudioStreaming() {\n    console.log('üõë Stopping WebRTC audio streaming...');\n    this.isStreaming = false;\n\n    // Stop audio processing\n    if (this.processor) {\n      this.processor.disconnect();\n      \n      // Clean up AudioWorkletNode port if it exists\n      if (this.processor.port) {\n        this.processor.port.onmessage = null;\n      }\n      \n      this.processor = null;\n    }\n\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n\n    // Close WebSocket\n    if (this.signalingSocket) {\n      this.signalingSocket.close();\n      this.signalingSocket = null;\n    }\n\n    // Stop media stream\n    if (this.mediaStream) {\n      this.mediaStream.getTracks().forEach(track => track.stop());\n      this.mediaStream = null;\n    }\n\n    this.notifyListeners({ type: 'status', data: 'Stopped ‚èπÔ∏è' });\n    console.log('‚úÖ WebRTC audio streaming stopped');\n  }\n\n  // Force cleanup - useful for debugging\n  forceCleanup() {\n    console.log('üî• Force cleanup: clearing all listeners and stopping streaming');\n    this.listeners.clear();\n    this.stopAudioStreaming();\n  }\n}\n\n// Create singleton instance\nconst webRTCService = new WebRTCService();\n\n// Make it available globally for debugging\nif (typeof window !== 'undefined') {\n  window.webRTCService = webRTCService;\n  console.log('üîß WebRTCService available globally as window.webRTCService');\n}\n\nexport default webRTCService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}